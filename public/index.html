<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quill Editor</title>
    <link
      rel="stylesheet"
      href="https://cdn.quilljs.com/1.3.6/quill.snow.css"
    />

    <!-- Include stylesheet -->
    <link
      href="https://cdn.jsdelivr.net/npm/quill@2.0.1/dist/quill.snow.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/he/he.js"></script>
  </head>

  <!-- Create the editor container -->
  <div id="editor">
    <p>Hello World!</p>
    <p><br /></p>
  </div>

  <!-- Include the Quill library -->
  <script src="https://cdn.jsdelivr.net/npm/quill@2.0.1/dist/quill.js"></script>

  <!-- Initialize Quill editor -->

  <script>
    //Import Quill namespace dependencies
    const BlockEmbed = Quill.import("blots/block/embed");
    console.log(BlockEmbed);

    class CustomHtmlBlot extends BlockEmbed {
      static create(value) {
        let node = super.create();
        // Create a container for both the text and the button

        node.innerHTML = value.html;
        return node;
      }

      static value(node) {
        return {
          html: node.innerHTML,
        };
      }
    }

    CustomHtmlBlot.blotName = "customHtml";
    CustomHtmlBlot.tagName = "div"; // Use a div to wrap the content
    Quill.register(CustomHtmlBlot);

    const Inline = Quill.import("blots/inline");

    class EditableSpan extends Inline {
      static create(value) {
        let node = super.create();
        node.setAttribute("id", value.id); // Set the ID attribute
        node.setAttribute("contenteditable", "true"); // Make the span editable

        // Create a blockquote element child
        const blockquote = document.createElement("blockquote");
        blockquote.innerText = value.content.text; // Set the text inside blockquote

        // Create a footer element
        const footer = document.createElement("blockquote");
        const br = document.createElement("p");
        footer.innerText = `-- ${value.content.title} by ${value.content.author}`; // Set the text inside footer

        // Append blockquote and footer to the node
        node.appendChild(blockquote);
        node.appendChild(br);
        node.appendChild(br)
        node.appendChild(footer);
        node.appendChild(br);

        return node;
      }

      static value(node) {
        return {
          id: node.getAttribute("id"),
          content: node.innerHTML,
        };
      }
    }

    EditableSpan.blotName = "editableSpan";
    EditableSpan.className = "editable-span";
    EditableSpan.tagName = "div";
    Quill.register(EditableSpan);

    class BoxHTML extends BlockEmbed {
      static create(value) {
        let node = super.create();
        node.setAttribute("id", value.id); // Set the ID attribute
        node.setAttribute("data-text", value.content); // Set the data-text attribute
        node.setAttribute("contenteditable", "true"); // Make the div non-editable
        // Create a container div that includes both the editable text and the button
        node.innerHTML = `<div style="display: flex; align-items: center;">
                        <span contenteditable="true" style="flex-grow: 1;">${value.content}</span>
                        <button onclick="alert('Button clicked! ${value.id}')">Click Me</button>
                      </div>`;

        return node;
      }

      static value(node) {
        return {
          content: node.querySelector('span[contenteditable="true"]').innerHTML,
          id: node.id,
        }; // Assuming ID is still relevant for your use case
      }
    }

    // get text of surrounding p at cursor
    function getSurroundingText() {
      const range = quill.getSelection();
      const [line, offset] = quill.getLine(range.index);
      const text = line.domNode.textContent;
      return text;
    }

    BoxHTML.blotName = "boxHtml";
    BoxHTML.tagName = "div"; // Use a div to wrap the content
    Quill.register(BoxHTML);

    // Initialize Quill
    const quill = new Quill("#editor", {
      theme: "snow",
      modules: {
        toolbar: {
          container: [
            ["customHtmlButton"], // Custom button
          ],
          handlers: {
            customHtmlButton: function () {
              const htmlContent = he.decode(
                `I said, “The moment you admit that questions of right and wrong relate to the well-being of conscious creatures—in this case, human beings—then you have to admit that we know something about morality. And we know, in this case, that the burqa isn’t the best solution to the mystery of how to maximize human well-being.” “That’s just your opinion,” she said. “Well, let’s make it simpler. Let’s say we found a culture on an island somewhere that was removing the eyeballs of every third child. Would you then agree that we had found a culture that was not perfectly maximizing human well-being?” “It would depend on why they were doing it,” she said. “Let’s say they’re doing it for religious reasons. They have a scripture which says, ‘Every third should walk in darkness,’ or some such nonsense.” Then she said, “Well, then you could never say that they were wrong.” The fact that these hypothetical barbarians were laboring under a religious precept trumped all other possible truth claims for her, leaving us with no way to declare anything better or worse in moral terms.`
              );

              const range = quill.getSelection(true);
              let text = null; 
              if (range.length === 0) {
                text = getSurroundingText();
                console.log(text);
                return;
              } else {
                quill.getText(range.index, range.length);
              }

            
              fetch("http://localhost:3000/query", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  text: text,
                }),
              })
                .then((res) => res.json())
                .then((data) => {
                  // extract text 
                    let offset = 0;
                    let firstElement = [data[0]];
                    data.forEach((da) => {
                      const id = Math.random().toString(36).substring(7);
                      const buttonHtml = `<button id="btn-${id}" onclick=\"alert('parent: ${range}')\">Sources</button>`;
                      quill.insertText(range.index + range.length + 1, " ", Quill.sources.USER);
                      quill.insertEmbed(
                        range.index + range.length + offset + 1,
                        "editableSpan",
                        { id: `${id}`, content: da },
                        Quill.sources.USER
                      );
                      // quill.insertEmbed(
                      //   range.index + offset + text.length + 1,
                      //   "customHtml",
                      //   { html: buttonHtml },
                      //   Quill.sources.USER
                      // );
                      quill.setSelection(
                        range.index + offset + range.length + text.length + buttonHtml.length + 1,
                        Quill.sources.SILENT
                      );
                    });
                    offset += text.length;

                });

              // if (range) {
              //   for (let i = 0; i < 3; i++) {
              //     const id = Math.random().toString(36).substring(7);

              //     // box html version
              //     // quill.insertEmbed(
              //     //   range.index,
              //     //   "boxHtml",
              //     //   {
              //     //     content: htmlContent,
              //     //     id: Math.random().toString(36).substring(7),
              //     //   },
              //     //   Quill.sources.USER
              //     // );

              //     // editable span version
              //     const buttonHtml = `<button id="btn-${id}" onclick=\"alert('parent: ${range}')\">Click Me</button>`;
              //     quill.insertText(range.index, " ", Quill.sources.USER);
              //     quill.insertEmbed(
              //       range.index + 1,
              //       "editableSpan",
              //       { id: `${id}`, content: htmlContent },
              //       Quill.sources.USER
              //     );
              //     quill.insertEmbed(
              //       range.index + htmlContent.length + 1,
              //       "customHtml",
              //       { html: buttonHtml },
              //       Quill.sources.USER
              //     );
              //     quill.setSelection(
              //       range.index + htmlContent.length + buttonHtml.length + 1,
              //       Quill.sources.SILENT
              //     );
              //   }
              // }
            },
          },
        },
      },
    });

    // whenever text is changed log all the button ids
    quill.on("text-change", function (delta, oldDelta, source) {
      const buttonIds = [];
      const sem = quill.getSemanticHTML();
      // parse sem to get button ids
      const parser = new DOMParser();
      const doc = parser.parseFromString(sem, "text/html");
      const buttons = doc.querySelectorAll("button");
      buttons.forEach((button) => {
        buttonIds.push(button.id);
      });
      // do the same for editable-span ids
      const spans = doc.querySelectorAll(".editable-span");
      const spanIds = [];
      spans.forEach((span) => {
        spanIds.push(span.id);
      });

      // if an id in buttons but not in spanIds, remove the button
      buttonIds.forEach((buttonId) => {
        const btnIdRm = buttonId.replace("btn-", "");
        if (!spanIds.includes(btnIdRm)) {
          // Use includes on the array of ids
          const button = document.getElementById("btn-" + btnIdRm);
          if (button) button.remove();
        }
      });
    });

    // Append the button to Quill's toolbar
    const toolbar = quill.getModule("toolbar");
    const buttonContainer = document.querySelector(".ql-toolbar");
    const button = document.createElement("button");
    button.innerHTML = "Add HTML";
    button.onclick = () => toolbar.handlers.customHtmlButton();
    buttonContainer.appendChild(button);
  </script>
</html>
