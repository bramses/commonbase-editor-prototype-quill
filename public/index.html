<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Quill Editor</title>
    <link
      rel="stylesheet"
      href="https://cdn.quilljs.com/1.3.6/quill.snow.css"
    />

    <!-- Include stylesheet -->
    <link
      href="https://cdn.jsdelivr.net/npm/quill@2.0.1/dist/quill.snow.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/he/he.js"></script>
  </head>

  <!-- Create the editor container -->
  <div id="editor">
    <p>Hello World!</p>
    <p><br /></p>
  </div>

  <!-- Include the Quill library -->
  <script src="https://cdn.jsdelivr.net/npm/quill@2.0.1/dist/quill.js"></script>

  <!-- <script src="/scripts/sse-js/lib/sse.js"></script>
  <script>
    console.log(SSE)
  </script> -->

  <!-- Initialize Quill editor -->

  <script>
    //Import Quill namespace dependencies
    const BlockEmbed = Quill.import("blots/block/embed");

    class CustomHtmlBlot extends BlockEmbed {
      static create(value) {
        let node = super.create();
        // Create a container for both the text and the button

        node.innerHTML = value.html;
        return node;
      }

      static value(node) {
        return {
          html: node.innerHTML,
        };
      }
    }

    CustomHtmlBlot.blotName = "customHtml";
    CustomHtmlBlot.tagName = "div"; // Use a div to wrap the content
    Quill.register(CustomHtmlBlot);

    const Inline = Quill.import("blots/inline");

    class EditableSpan extends Inline {
      static create(value) {
        let node = super.create();
        node.setAttribute("id", value.id); // Set the ID attribute
        node.setAttribute("contenteditable", "true"); // Make the span editable

        console.log(value.content);
        // Create a blockquote element child
        const blockquote = document.createElement("blockquote");
        blockquote.innerText = value.content.data; // Set the text inside blockquote

        // Create a footer element
        const footer = document.createElement("blockquote");
        const br = document.createElement("p");
        footer.innerText = `-- ${value.content.metadata.url} by ${value.content.metadata.screen_name}`; // Set the text inside footer

        // Append blockquote and footer to the node
        node.appendChild(blockquote);
        node.appendChild(br);
        node.appendChild(br);
        node.appendChild(footer);
        node.appendChild(br);

        return node;
      }

      static value(node) {
        return {
          id: node.getAttribute("id"),
          content: node.innerHTML,
        };
      }
    }

    EditableSpan.blotName = "editableSpan";
    EditableSpan.className = "editable-span";
    EditableSpan.tagName = "div";
    Quill.register(EditableSpan);

    class BoxHTML extends BlockEmbed {
      static create(value) {
        let node = super.create();
        node.setAttribute("id", value.id); // Set the ID attribute
        node.setAttribute("data-text", value.content); // Set the data-text attribute
        node.setAttribute("contenteditable", "true"); // Make the div non-editable
        // Create a container div that includes both the editable text and the button
        node.innerHTML = `<div style="display: flex; align-items: center;">
                        <span contenteditable="true" style="flex-grow: 1;">${value.content}</span>
                        <button onclick="alert('Button clicked! ${value.id}')">Click Me</button>
                      </div>`;

        return node;
      }

      static value(node) {
        return {
          content: node.querySelector('span[contenteditable="true"]').innerHTML,
          id: node.id,
        }; // Assuming ID is still relevant for your use case
      }
    }

    // get text of surrounding p at cursor
    function getSurroundingText() {
      const range = quill.getSelection();
      const [line, offset] = quill.getLine(range.index);
      const text = line.domNode.textContent;
      return text;
    }

    BoxHTML.blotName = "boxHtml";
    BoxHTML.tagName = "div"; // Use a div to wrap the content
    Quill.register(BoxHTML);

    // Initialize Quill
    const quill = new Quill("#editor", {
      theme: "snow",
      modules: {
        toolbar: {
          container: [
            ["customHtmlButton"], // Custom button
          ],
          handlers: {
            customHtmlButton: function () {
              const range = quill.getSelection(true);
              let text = null;
              if (range.length === 0) {
                text = getSurroundingText();
                return;
              } else {
                text = quill.getText(range.index, range.length);
              }

              fetch("http://localhost:3000/query", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  text: text,
                }),
              })
                .then((res) => res.json())
                .then((data) => {
                  // extract text
                  let offset = 0;
                  appendToHistory(text, "search", data);
                  data.forEach((da) => {
                    const id = Math.random().toString(36).substring(7);
                    const buttonHtml = `<button id="btn-${id}" onclick=\"alert('parent: ${range}')\">Sources</button>`;
                    // insert at end of quill
                    quill.insertText(
                      quill.getLength(),
                      " ",
                      Quill.sources.USER
                    );
                    quill.insertEmbed(
                      quill.getLength(),
                      "editableSpan",
                      { id: `${id}`, content: da },
                      Quill.sources.USER
                    );
                    // quill.insertEmbed(
                    //   range.index + offset + text.length + 1,
                    //   "customHtml",
                    //   { html: buttonHtml },
                    //   Quill.sources.USER
                    // );
                    quill.setSelection(
                      range.index +
                        offset +
                        range.length +
                        text.length +
                        buttonHtml.length +
                        1,
                      Quill.sources.SILENT
                    );
                  });
                  offset += text.length;
                });
            },
          },
        },
      },
    });

    // whenever text is changed log all the button ids
    quill.on("text-change", function (delta, oldDelta, source) {
      const buttonIds = [];
      const sem = quill.getSemanticHTML();
      // parse sem to get button ids
      const parser = new DOMParser();
      const doc = parser.parseFromString(sem, "text/html");
      const buttons = doc.querySelectorAll("button");
      buttons.forEach((button) => {
        buttonIds.push(button.id);
      });
      // do the same for editable-span ids
      const spans = doc.querySelectorAll(".editable-span");
      const spanIds = [];
      spans.forEach((span) => {
        spanIds.push(span.id);
      });

      // if an id in buttons but not in spanIds, remove the button
      buttonIds.forEach((buttonId) => {
        const btnIdRm = buttonId.replace("btn-", "");
        if (!spanIds.includes(btnIdRm)) {
          // Use includes on the array of ids
          const button = document.getElementById("btn-" + btnIdRm);
          if (button) button.remove();
        }
      });
    });

    // Append the button to Quill's toolbar
    const toolbar = quill.getModule("toolbar");
    const buttonContainer = document.querySelector(".ql-toolbar");
    const button = document.createElement("button");
    button.innerHTML = "Search";
    // add margin to the button
    button.style.marginLeft = "10px";
    button.style.marginRight = "10px";
    button.onclick = () => toolbar.handlers.customHtmlButton();
    buttonContainer.appendChild(button);

    // create another button for sse
    const sseButton = document.createElement("button");
    sseButton.innerHTML = "SSE";
    sseButton.style.marginLeft = "10px";
    sseButton.style.marginRight = "10px";
    // EventSource = SSE;
    sseButton.onclick = () => {
      console.log("SSE button clicked");

      // make a confirmation dialog
      const confirm = window.confirm(
        "Are you sure you want to use Server Sent Events?"
      );

      if (!confirm) {
        return;
      }

      const highlightedText = quill.getText(quill.getSelection());

      var eventSource = new EventSource("/events?payload=" + highlightedText, {
        withCredentials: true,
      });
      const end = quill.getLength();
      let cursorEnd = end;
      let fullMessage = "";
      eventSource.onmessage = function (event) {
        // write at end of file

        // insert text at cursor position
        quill.insertText(cursorEnd, event.data.replaceAll('"', ""));
        // set cursor to end of data
        quill.setSelection(cursorEnd + event.data.length);
        cursorEnd += event.data.length - 2;
        fullMessage += event.data;
        // console.log(event.data);
        // console.log(cursorEnd);
      };

      eventSource.onerror = function (event) {
        if (eventSource.readyState == EventSource.CLOSED) {
          console.log("EventSource closed:", event);
          console.log(fullMessage);

          appendToHistory(highlightedText, "context", fullMessage);
          eventSource.close();
        } else {
          console.error("EventSource failed:", event);
          eventSource.close();
        }
      };

      // eventSource.onopen = function (event) {
      //   console.log("EventSource opened:", event);
      // };

      // eventSource.onclose = function (event) {
      //   console.log("EventSource closed:", event);
      //   console.log(fullMessage);

      //   appendToHistory(highlightedText, 'context', fullMessage);
      // };
    };
    buttonContainer.appendChild(sseButton);

    // add a button that allows user to see highlighted text
    const history = [];

    const appendToHistory = (cause, action, result) => {
      history.push({ cause, action, result });
    };

    const historyButton = document.createElement("button");
    historyButton.innerHTML = "History";
    historyButton.style.marginLeft = "10px";
    historyButton.style.marginRight = "10px";
    historyButton.onclick = () => {
      const range = quill.getSelection();
      const text = quill.getText(range.index, range.length);
      alert("check console for history");
      console.log(history);
    };

    buttonContainer.appendChild(historyButton);
  </script>
</html>
